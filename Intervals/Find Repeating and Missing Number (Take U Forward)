1. Using Map

class Solution {
   public:
    vector<int> findMissingRepeatingNumbers(vector<int> nums) {

        unordered_map<int,int> freqMap;
        int n = nums.size();
        for(auto num:nums) freqMap[num]++;
        int twice,na;
        for(int i=1; i<=n; i++){
            if(freqMap[i]==0) na = i;
            if(freqMap[i]==2) twice = i;
        }
        return {twice,na};



    }
};


2. Using sum formula

class Solution {
public:
    vector<int> findMissingRepeatingNumbers(vector<int> nums) {
        int n = nums.size();
        long long sn = 1LL*n*(n+1)/2;
        long long s2n = sn * (2*n + 1)/3;
        long long s=0,s2=0;
        for(auto num:nums){
            s += num;
            s2 += (1LL*num*num);
        }
        
        long long alpha = sn-s;
        
        long long beta = (s2n-s2)/(sn-s);

        //cout<<beta<<endl;
        int missing = (alpha + beta) / 2;
        int repeating = missing-alpha;
        return {repeating, missing};

    }
};

3. Bit Manuplation
class Solution {
public:
    vector<int> findMissingRepeatingNumbers(vector<int> nums) {
        int xorc=0;
        int n = nums.size();
        for(int i=0; i<nums.size(); i++){
            xorc ^= nums[i];
            xorc ^= (i+1);
        }
        //xorc(xor combined) is xor of missing and repeating
        int bitindex = 0;
        for(int i=0; i<32; i++){
            if(xorc & (1<<i)) {
                bitindex = i;
                break;
            }
        }

       int one = 0, zero = 0;
       for(int i=0; i<n; i++){
        if(nums[i] & (1<<bitindex)) one ^= nums[i];
        else zero ^= nums[i];
        if(i+1 & (1<<bitindex)) one ^= (i+1);
        else zero ^= (i+1);
       }
        int cntzero = 0;
        for(auto num:nums){
            if(num==zero) cntzero++;
        }
        if(cntzero==2) return {zero, one};
        return {one, zero};

    }
};
